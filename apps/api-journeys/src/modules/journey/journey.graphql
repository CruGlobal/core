type Journey {
  id: ID!
  published: Boolean!
  title: String!
  blocks: [JourneyStep!]!
}

union JourneyStep = Block | Condition

type Condition {}

type Block {
  id: ID!
  mediaElement: MediaElement
  interactiveElements: [InteractiveElement!]!
}

union MediaElement = MediaWithOverlaidInteractions | MarkdownTextMedia |
                      TextWithBackgroundMedia | AudioMedia | Signup

interface MediaWithOverlaidInteractions {
  overlaidInteractions: [OverlaidInteraction]!
  mediaURI: URI!
}

type VideoMedia implements MediaWithOverlaidInteractions {
  startTimestamp: String
  endTimestamp: String
  autoplay: Boolean!
  repeat: Boolean!
}

type PhotoMedia implements MediaWithOverlaidInteractions {
}

type MarkdownTextMedia {
  text: String!
}

type TextWithBackgroundMedia {
  mediaURI: URI!
  text: String!
}

type AudioMedia {
  mediaURI: URI!
  startTimestamp: String
  endTimestamp: String
  autoplay: Boolean!
  repeat: Boolean!
}

type OverlaidInteraction {
  appearAtTimestamp: String!
  InteractiveElement: InteractiveElement!
}

union InteractiveElement = MCSRQuestion | SliderInput | MarkdownTextMedia |
                             Image | Button | ImagePickQuestion | DelayedElement

type MCSRQuestion {
  id: ID!
  question: String!
  answerOptions: [Answer!]!
}

type Answer {
  id: ID!
  text: String
}

type SliderInput {
  id: ID!
  question: String!
  leftLabel: String!
  rightLabel: String!
}

type Image {
  mediaURI: URI!
}

type Button {
  id: ID!
  label: String!
  style: ButtonStyle
}

type ImagePickQuestion {
  id: ID!
  prompt: String
  images: [Image!]!
}

# TODO figure out how to only allow these on time-based media
# TODO figure out how to not allow DelayedElement as element of a DelayedElement
type DelayedElement {
  appearAtTimestamp: String!
  element: InteractiveElement!
}
